

# day 2

## 一、协同过滤算法

协同过滤（collaborative Filtering）：根据用户之前的喜好以及其他兴趣相近的用户的选择来给用户推荐物品，基于用户行为数据，而不考虑附加信息

基于领域的方法：

> 基于用户的协同过滤算法（UserCF）：给用户推荐和他兴趣相似的其他用户喜欢的产品
>
> 基于物品的协同过滤算法（ItemCF）：给用户推荐和他之前喜欢的物品相似的物品

## 二、相似性度量方法

### 1. 杰卡德（Jaccard）相似系数

两个集合的杰卡德：两个用户交互商品的交集数量占这两个用户交互商品并集的数量比例
$$
用户 u, 用户 v，这两个用户的杰卡德相似系数sim_{uv},N(u),N(v)分别表示u，v交互商品的集合
$$
由于杰卡德下属不反应用户的评分喜好信息，所以常用于评估用户是否对商品评分
$$
sim_{uv}=\frac{|N(u) \cap N(v)|}{|N(u)| \cup|N(v)|}
$$


### 2. 余弦相似度

分母不再是两用户交互商品的并集数量，而是分别交互的商品数量乘积
$$
sim_{uv}=\frac{|N(u) \cap N(v)|}{|N(u)|\cdot|N(v)|}
$$
令 N 为用户 - 商品交互矩阵，得到
$$
sim_{uv} = cos(u,v) =\frac{u\cdot v}{|u|\cdot |v|} 
$$
（对大规模稀疏矩阵，余弦相似度常使用集合方式计算）

求和形式
$$
r_{ui},r_{vi}分别表示用户u和用户v对商品i是否有交互（或具体的评分值）
$$

$$
sim_{uv} = \frac{\sum_i r_{ui}*r_{vi}}{\sqrt{\sum_i r_{ui}^2}\sqrt{\sum_i r_{vi}^2}}
$$

python 掉包运行 cosine_similarity

```python
from sklearn.metrics.pairwise import cosine_similarity
i = [1, 0, 0, 0]
j = [1, 0.5, 0.5, 0]
cosine_similarity([i, j])
```
### 3. 皮尔逊相关系数

$$
\bar r_u, \bar r_v 分别表示用户u和用户v交互的所有商品交互数量或具体评分的均值
$$

$$
sim(u,v)=\frac{\sum_{i\in I}(r_{ui}-\bar r_u)(r_{vi}-\bar r_v)}{\sqrt{\sum_{i\in I }(r_{ui}-\bar r_u)^2}\sqrt{\sum_{i\in I }(r_{vi}-\bar r_v)^2}}
$$

与余弦相似度比，皮尔逊相关系数使用用户的平均值对各个独立评分进行修正，减小了用户评分偏置的影响，其中python中的一种掉包如下

```python
from scipy.stats import pearsonr
i = [1, 0, 0, 0]
j = [1, 0.5, 0.5, 0]
pearsonr(i, j)
```

## 三、基于用户的协同过滤

### 1. UserCF基本概念

当一个用户u需要个性化推荐，先找到和他有相似兴趣的其他用户，然后把这些用户喜欢的，而u没听过的物品推荐给u  ----- 猜测用户对商品进行打分的任务

a. 找到和目标用户兴趣相似的集合

b. 找到这个集合中的用户喜欢的，而目标用户没听说过的物品推荐给目标用户

### 2. 最终结果的预测

利用用户相似度和相似用户的平均加权平均获得用户的评价预测
$$
w_{u,s}是用户u对用户s的相似度，R_{s,p}是用户s对物品p的评分
$$

$$
R_{\mathrm{u}, \mathrm{p}}=\frac{\sum_{\mathrm{s} \in S}\left(w_{\mathrm{u}, \mathrm{s}} \cdot R_{\mathrm{s}, \mathrm{p}}\right)}{\sum_{\mathrm{s} \in S} w_{\mathrm{u}, \mathrm{s}}}
$$

另一种 method（更全面）：

该物品的评分与此用户的所有评分的差值进行加权平均（考虑到用户内心的评分标准不一样）(?)
$$
P_{i, j}=\bar{R}{i}+\frac{\sum_{k=1}^{n}\left(S_{i, k}\left(R_{k, j}-\bar{R}{k}\right)\right)}{\sum_{k=1}^{n} S_{j, k}}
$$

### 3. 实例计算

|       | 物品1 | 物品2 | 物品3 | 物品4 | 物品5  |
| ----- | ----- | ----- | ----- | ----- | ------ |
| Alice | 5     | 3     | 4     | 4     | **？** |
| 用户1 | 3     | 1     | 2     | 3     | 3      |
| 用户2 | 4     | 3     | 4     | 3     | 5      |
| 用户3 | 3     | 3     | 1     | 5     | 4      |
| 用户4 | 1     | 5     | 5     | 2     | 1      |

#### a. 计算Alice与其他用户的相似度（皮尔逊相关系数）

通过上表，得到用户向量

这里计算 Alice 和 user1 的余弦相似性：
$$
sim(Alice,user1) = cos(Alice, user1) = \frac{15 + 3 + 8 + 12}{\sqrt{25 + 9 + 16 + 16} *\sqrt{9+1+4+9}}=0.975
$$
计算Alice和user1皮尔逊相关系数：
$$
Alice\_ave = 4, user1\_ave = 2.25
$$
向量减去均值得到
$$
Alice(1, -1, 0, 0), user1(0.75, -1.25, -0.25, 0.75)
$$
得到新向量的余弦相似度与原余弦相似度一致（？）



使用皮尔逊相关稀疏，同理可以计算得到其他用户的相似度，使用numpy的相似度函数得到用户的相似性矩阵

python_code:

```python
user = np.asarray([[5, 3, 4, 4], [3, 1, 2, 3], [4, 3, 4, 3], [3, 3, 1, 5], [1, 5, 5, 2]])
cos_sim = cosine_similarity(user)
corroef = np.corrcoef(user)
print('余弦相似性:\n {}'.format(cos_sim))
print('皮尔逊相关系数:\n {}'.format(corroef))
```

output.txt:

```txt
余弦相似性:
 [[1.         0.9753213  0.99224264 0.89072354 0.79668736]
 [0.9753213  1.         0.94362852 0.91160719 0.67478587]
 [0.99224264 0.94362852 1.         0.85280287 0.85811633]
 [0.89072354 0.91160719 0.85280287 1.         0.67082039]
 [0.79668736 0.67478587 0.85811633 0.67082039 1.        ]]
皮尔逊相关系数:
 [[ 1.          0.85280287  0.70710678  0.         -0.79211803]
 [ 0.85280287  1.          0.30151134  0.42640143 -0.88662069]
 [ 0.70710678  0.30151134  1.         -0.70710678 -0.14002801]
 [ 0.          0.42640143 -0.70710678  1.         -0.59408853]
 [-0.79211803 -0.88662069 -0.14002801 -0.59408853  1.        ]]
```

**从这里看出, Alice用户和用户2,用户3,用户4的相似度是0.7，0, -0.79。 所以如果n=2， 找到与Alice最相近的两个用户是用户1， 和Alice的相似度是0.85， 用户2， 和Alice相似度是0.7**

#### b. 根据相似度用户计算Alice对物品5的最终得分

$$
P_{Alice, 物品5}=\bar{R}{Alice}+\frac{\sum_{k=1}^{2}\left(S_{Alice,user k}\left(R_{userk, 物品5}-\bar{R}{userk}\right)\right)}{\sum_{k=1}^{2} S_{Alice, userk}}=4+\frac{0.85*(3-2.4)+0.7*(5-3.8)}{0.85+0.7}=4.87
$$

#### c. 根据用户评分对用户进行推荐

按照得分排序给Alice推荐物品1和物品5

## 四、UserCF编程实现

> 1. 计算用户相似性矩阵
> 2. 得到前n个相似用户
> 3. 计算最终得分

### 1. 建立数据表

字典方式存储数据（真实情况中，用户对物品的打分情况会很分散，导致大量的空值，所以矩阵会很稀疏，这个时候如果使用DataFrame，会有大量的NaN，所以用字典形式存储。

> 用两个字典：
>
> 第一个字典是物品-用户的评分映射，键是物品1 - 5，用A-E表示，每个值也是一个字典，表示每个用户对物品的打分；
>
> 第二个字典是用户-物品的评分映射，键是上面的五个用户，用1 - 5表示，值是用户对每个物品的打分

python_code:

```python
import pandas as pd

# 定义数据集，注意:采用字典存放数据，因为实际情况中数据是非常稀疏的
def loadData():
    items={'A': {1: 5, 2: 3, 3: 4, 4: 3, 5: 1},
           'B': {1: 3, 2: 1, 3: 3, 4: 3, 5: 5},
           'C': {1: 4, 2: 2, 3: 4, 4: 1, 5: 5},
           'D': {1: 4, 2: 3, 3: 3, 4: 5, 5: 2},
           'E': {2: 3, 3: 5, 4: 4, 5: 1}
          }
    users={1: {'A': 5, 'B': 3, 'C': 4, 'D': 4},
           2: {'A': 3, 'B': 1, 'C': 2, 'D': 3, 'E': 3},
           3: {'A': 4, 'B': 3, 'C': 4, 'D': 3, 'E': 5},
           4: {'A': 3, 'B': 3, 'C': 1, 'D': 5, 'E': 4},
           5: {'A': 1, 'B': 5, 'C': 5, 'D': 2, 'E': 1}
          }
    return items, users

items, users = loadData()
item_df = pd.DataFrame(items).T
user_df = pd.DataFrame(users).T
print('item_df:\n{}'.format(item_df))
print('user_df:\n{}'.format(user_df))
```

output.txt:

```txt
item_df:
     1    2    3    4    5
A  5.0  3.0  4.0  3.0  1.0
B  3.0  1.0  3.0  3.0  5.0
C  4.0  2.0  4.0  1.0  5.0
D  4.0  3.0  3.0  5.0  2.0
E  NaN  3.0  5.0  4.0  1.0
user_df:
     A    B    C    D    E
1  5.0  3.0  4.0  4.0  NaN
2  3.0  1.0  2.0  3.0  3.0
3  4.0  3.0  4.0  3.0  5.0
4  3.0  3.0  1.0  5.0  4.0
5  1.0  5.0  5.0  2.0  1.0
```

### 2. 计算用户相似性矩阵

5*5 的共现矩阵，行和列都代表用户，值代表用户间相似性，考虑两个用户，遍历物品-用户评分数据，在里面找这两个用户同时对该物品的评分数据放到这两个用户想两种。（其中会存在很多NaN值，即无法计算相似性）

python_code:

```python
'''计算用户相似性矩阵'''
similarity_matrix = pd.DataFrame(np.zeros((len(users), len(users))), index=[1, 2, 3, 4, 5], columns=[1, 2, 3, 4, 5])
# 遍历每条用户-物品评分数据
for userID in users:
    for otheruserID in users:
        vec_user = []
        vec_otheruser = []
        if userID != otheruserID:
            # print('userID:{}'.format(userID))
            # print('otheruserID:{}'.format(otheruserID))
            for itemID in items:
                itemRatings = items[itemID]
                if userID in itemRatings and otheruserID in itemRatings:
                    vec_user.append(itemRatings[userID])
                    vec_otheruser.append(itemRatings[otheruserID])
                # 这里可以获得相似性矩阵（共现矩阵）
            similarity_matrix[userID][otheruserID] = np.corrcoef(np.array(vec_user), np.array((vec_otheruser)))[0][1]
print('similarity_matrix:\n{}'.format(similarity_matrix))
```

output.txt:

```python
similarity_matrix:
          1         2         3         4         5
1  0.000000  0.852803  0.707107  0.000000 -0.792118
2  0.852803  0.000000  0.467707  0.489956 -0.900149
3  0.707107  0.467707  0.000000 -0.161165 -0.466569
4  0.000000  0.489956 -0.161165  0.000000 -0.641503
5 -0.792118 -0.900149 -0.466569 -0.641503  0.000000
```

得到与Alice最相关的前n个用户

### 3. 计算前n个相似的用户

